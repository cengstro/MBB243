---
title: "Self Quiz and Exercises for Week 6"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
knitr::opts_chunk$set(echo = FALSE)
```

## R data structures and functions


```{r,eval=T,echo=T}
a_mat <- matrix(1:8, ncol=2)
a_mat
```


### Q1

```{r q1, echo=FALSE}
question("Based on the contents of a_mat, which of the following code would print out the value 8 if added below the existing lines in the code chunk above?",
  answer("a_mat[2]"),
  answer("a_mat[2,]"),
  answer("a_mat[4]"),
  answer("a_mat[2,4]"),
  answer("a_mat[4,2]",correct = TRUE),
  answer("None of them")
)
```


### Q2

```{r q2, echo=FALSE}
question("Based on the contents of a_mat, which of the following code would return a vector containing these values: (5,6,7,8)?",
  answer("a_mat[2]"),
  answer("a_mat[2,]"),
  answer("a_mat[,2]",correct = TRUE),
  answer("a_mat[2,1]"),
  answer("a_mat[4,2]"),
  answer("None of them")
)
```


### Q3

Data frames can be created using a syntax similar to what we used when creating a list with named elements. The code below creates a data frame with three columns, as shown in the printout below. 

```{r,eval=T,echo=T}
df <- data.frame("first"=c("Doctor","The","Doctor","Dr.","Dr."),
                 "second"=c("Dre","Doctor","Octopus","Morin","Evil"),
                 "power"=c("Sick beats","Time travel","Robotic tentacles","confusion","evil"),
                 "coolness"=c(9,12,3,8,4),
                 row.names=c("a","b","c","d","e"))

```

```{r q3,echo=FALSE}
question("Which of the following will return a data frame with the same contents but with the rows arranged from lowest to highest coolness score?",
  answer("df[order(df$coolness)]"),
  answer("df[order(df$coolness),]",correct = TRUE),
  answer("df[,order(df$coolness)]"),
  answer("df[order(rownames(df)),]")
)
```

### Q4

```{r q4, echo=FALSE}
question("Which code will produce a data frame containing only rows with the first name set to either Dr or Doctor?",
  answer("None of them"),
  answer("df[grepl('D',df$first)]"),
  answer("df[grepl('D',df$first),]",correct = TRUE),
  answer("df[grepl('Doctor',df$first),]")
)
```


```{r,echo=T,eval=T}

days <- c("Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday")


```

### Q5

```{r q5, echo=FALSE}
question("Which line of code would subset the days vector to just weekdays?",
  answer("None of them"),
  answer("days[ grepl('S',days)]"),
  answer("! days[ grepl('S',days)]"),
  answer("days[ !grepl('S',days)]",correct = TRUE)
)
```

### Q6

```{r q6, echo=FALSE}
question("Which of the following statements comparing R data frames and matrixes are accurate?",
  answer("Matrix and data frames both enforce unique row and column names"),
  answer("Both can only contain data of a single type"),
  answer("Rows or columns can be subset directly into vectors using [] sytax and the corresponding row or column index"),
  answer("In data frames, columns can contain a mix of data types but matrixes do not allow this."),
  answer("None of the statements are accurate",correct = TRUE)
)
```


### Getting vexxed by vectors

*Add to the code below to create a new vector from this_vec that contains the elements in numerical order. Your code should print the contents of your new vector. When you have the correct implementation, you should get a printout identical to what is shown immediately below this.*

```{r,echo=F,eval=T}
this_vec = c(8,22,12,40,3,1)
this_vec[order(this_vec)]
```

In your solution you must use the `order` function. 

```{r try1, exercise=TRUE, exercise.lines = 5}
this_vec = c(8,22,12,40,3,1)

```

*Add to the code below to create a new vector from this_vec that contains the elements in numerical order. When you have the correct implementation, you should get a printout identical to what is shown immediately below this.*


```{r try2, exercise=TRUE, exercise.lines = 5}
this_list = list(z="?",y="hard",m="really",c="now",f="was",w="so")

```

### Listing everything you like about lists

*Add to the code below to create a new vector from this_list that contains the elements in the order according to the names (not the values). Once you have that, print the vector contents. When you have the correct implementation, you should get a sensible sentence with proper punctuation (below the corresponding names from the original list).*

Hint/warning: Although `[[]]` is useful for getting a vector out of a list, you can't use it with vectors of length >1. 

```{r print-limit, exercise=TRUE, exercise.eval=TRUE}
this_list = list(h="that",z="?",y="difficult",m="really",c="Now",f="was",w="so")
```

```{r print-limit-hint}
order(names(this_list)) #here is the first step you will need. 

```

### Controlling The Matrix (like Neo)

*Add to the code below to order the columns of the matrix based on the numeric values in the second row (i.e. row index 2). Print out the ordered matrix when you're done. You should be able to see a secret message in the bottom two lines of your matrix when you have the correct answer. *

```{r reorder, exercise=TRUE, exercise.eval=TRUE}

alpha_mat = matrix(c("M","z","d","E","w","o","o","G","L","J","o","o","A","c","G","D"),nrow=4)
alpha_mat
```

```{r reorder-hint}
order(alpha_mat[2,]) #this should get you started
```

### Can't think of a way to frame a pun about data

*The code below loads the first 125,000 of Ryan's genotypes from 23andMe. Add some code below this to subset this data frame to create a new data frame containing only rows that are heterozygous (not homozygous). Be sure the data frame doesn't contain any "no call" genotypes, which look like this: "--". When you have the right answer, you should have a data frame with 59930 rows. Confirm this by running the dim() function on your new data frame. *

```{r df, exercise=TRUE, exercise.eval=TRUE}

morin = read.csv("../data/Morin_genotypes.txt",sep="\t",nrows = 125000)
table(morin$genotype)

```
###
